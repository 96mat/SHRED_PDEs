#%%
from pyshred import DataManager, SHRED, SHREDEngine, SINDy_Forecaster
import torch
import numpy as np
import matplotlib.pyplot as plt
#%%
data=np.load("MHD_values/shred_dataset.npz")
print(data["X"].shape)
plt.imshow(data["X"])
data=torch.tensor(data["X"])
#%%
manager = DataManager(
    lags=200, #       # 1 year of weekly history as input
    train_size=0.8,   # 0.68 + 0.22 + 0.10 = 1.0
    val_size=0.1,
    test_size=0.1,
)
#%%
manager.add_data(
    data=data,         # 3D array (time, lat, lon); time must be on axis 0
    id="MHD-Bal",          # Unique identifier for the dataset
    random=5,          # Randomly select 3 sensor locations
    compress=False    # Keep original spatial resolution (no compression)
)
#%%
manager.sensor_summary_df
# %%
pos=manager.sensor_summary_df.iloc[:,3].to_numpy() # Retrieve position of random sensors
# %%
manager.sensor_measurements_df
# %%
train_dataset, val_dataset, test_dataset= manager.prepare()
# %%
import torch
device = 'cuda' if torch.cuda.is_available() else ('mps' if torch.backends.mps.is_available() else 'cpu')
from pyshred.models.latent_forecaster_models.lstm import *

LSTM_Custom = LSTM_Forecaster(
    lags=20,          # numero di step temporali di memoria
    hidden_size=50,  # neuroni per layer
    num_layers=10,    # profondità LSTM
)
from pyshred.models.sequence_models.lstm_model import *
LSTM_BaseCustom = LSTM(
    hidden_size=64,   # neuroni per layer
    num_layers=10,    # profondità LSTM
)                     # ora la dimensione del latent-space è 80

shred = SHRED(
    sequence_model=LSTM_BaseCustom,
    decoder_model="MLP",
    latent_forecaster=LSTM_Custom
)

"""shred.to(device)
print("Device:", device)
print(type(shred))"""
# %%
from time import perf_counter
start=perf_counter()

val_errors = shred.fit(
    train_dataset=train_dataset,
    val_dataset=val_dataset,
    num_epochs=500,
    patience=50,
    batch_size=128,
    lr=5e-3,
    verbose=True
)
# %%
stop=perf_counter()
print(f'elapsed time = {stop-start:.3f}[s]')
print(val_errors.shape)
#.cpu().numpy()
plt.figure(figsize = (8,5))
plt.plot(val_errors, 'orange', linewidth = 3, label = 'Validation error')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)
# %%
train_mse = shred.evaluate(dataset=train_dataset)
val_mse = shred.evaluate(dataset=val_dataset)
test_mse = shred.evaluate(dataset=test_dataset)
print(f"Train MSE: {train_mse:.3f}")
print(f"Val   MSE: {val_mse:.3f}")
print(f"Test  MSE: {test_mse:.3f}")
# %%
engine = SHREDEngine(manager, shred)
print(type(engine))
# %%
test_latent_from_sensors = engine.sensor_to_latent(manager.test_sensor_measurements)
print(f"to be sent to latent = {np.shape(manager.test_sensor_measurements)}")
print(np.shape(test_latent_from_sensors))
# %%
# generate latent states from validation sensor measurements
val_latents = engine.sensor_to_latent(manager.val_sensor_measurements)
print(f"val_latents = {np.shape(val_latents)}")
# seed the forecaster with the final `seed_length` latent states from validation
init_latents = val_latents[-shred.latent_forecaster.seed_length:] # seed forecaster with final lag timesteps of latent space from val
print(shred.latent_forecaster.seed_length)
print(f"init_latents = {np.shape(init_latents)}")
print(init_latents.shape)
# set forecast horizon to match the length of the test dataset
h = len(manager.test_sensor_measurements)
print(h)
# forecast latent states for the test horizon
test_latent_from_forecaster = engine.forecast_latent(h=h, init_latents=init_latents)
# %%
# decode latent space generated from sensor measurements (generated using engine.sensor_to_latent())
test_reconstruction = engine.decode(test_latent_from_sensors)

# decode latent space generated by the latent forecaster (generated using engine.forecast_latent())
test_forecast = engine.decode(test_latent_from_forecaster)

# %%
# ---------------- Train Evaluation ----------------
t_train = len(manager.train_sensor_measurements)
train_Y = {"MHD-Bal": data[0:t_train]}  # Ground truth segment
train_error = engine.evaluate(manager.train_sensor_measurements, train_Y)

# ---------------- Validation Evaluation ----------------
t_val = len(manager.val_sensor_measurements)
val_Y = {"MHD-Bal": data[t_train:t_train + t_val]}
val_error = engine.evaluate(manager.val_sensor_measurements, val_Y)

# ---------------- Test Evaluation ----------------
t_test = len(manager.test_sensor_measurements)
test_Y = {"MHD-Bal": data[-t_test:]}
test_error = engine.evaluate(manager.test_sensor_measurements, test_Y)

# ---------------- Print Results ----------------
print("---------- TRAIN ----------")
print(train_error)

print("\n---------- VALIDATION ----------")
print(val_error)

print("\n---------- TEST ----------")
print(test_error)# %%

# %%
import numpy as np

# Final ground truth frame from the test set
truth = data[-1]

# Extract final reconstructed frame (from sensor-based latents)
reconstructions = test_reconstruction["MHD-Bal"]
reconstruction = reconstructions[h - 1]

# Extract final forecasted frame (from forecasted latents)
forecasts = test_forecast["MHD-Bal"]
forecast = forecasts[h -1]
print(f"shape: {forecast.shape}")
vmin_original=np.min(forecast)
vmax_original=np.max(forecast)

# %%
#np.savez("SHRED_reconstruction.npz",reconstruction)
# %%
